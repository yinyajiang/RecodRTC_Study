<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <button id="btn-start-recording">Start Recording</button>
    <button id="btn-stop-recording" disabled>Stop Recording</button>
    <button id="btn-pause-recording" disabled>Pause Recording</button>
    <button id="btn-resume-recording" disabled>Resume Recording</button>
    <button id="btn-download-recording" disabled>Download</button>
    <button id="btn-reset">Reset</button>

    <br /><br />

    <input type="checkbox" id="checkbox-camera" checked> Camera</checkbox>
    <input type="checkbox" id="checkbox-microphone"> Microphone</input>
    <input type="checkbox" id="checkbox-screen">Screen</input>
    <input type="checkbox" id="checkbox-system-audio"> System Audio</input>


    <hr>
    <div>
        <audio controls autoplay playsinline></audio>
        <video controls autoplay playsinline style="width: 200px; height: 200px;"></video>
    </div>

    <script src="https://www.WebRTC-Experiment.com/RecordRTC.js"></script>

    <script> //utils
        function IsEdge() {
            if (typeof window.__isEdge !== 'undefined') {
                return window.__isEdge;
            }
            window.__isEdge = navigator.userAgent.indexOf('Edge') !== -1 && (!!navigator.msSaveOrOpenBlob || !!navigator.msSaveBlob);
            return window.__isEdge;
        }

        function IsSafari() {
            if (typeof window.__isSafari !== 'undefined') {
                return window.__isSafari;
            }
            window.__isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
            return window.__isSafari;
        }

        class MediaRecorderApp {
            constructor(options) {
                this._initUIListeners(options.events);
            }

            capture(captures) {
                this._captures = captures;
            }

            onStop(callback) {
                this._addUICallback('stop', callback);
            }
            onDownload(callback) {
                this._addUICallback('download', callback);
            }
            onStart(callback) {
                this._addUICallback('start', callback);
            }
            onPause(callback) {
                this._addUICallback('pause', callback);
            }
            onResume(callback) {
                this._addUICallback('resume', callback);
            }

            reset() {
                this._preview('videoRecordingPreview', null);
                this._preview('videoFinishPreview', null);
                this._preview('audioFinishPreview', null);
                this._close(true);
                this._enableEle('start', true);
                this._enableEle('stop', false);
                this._enableEle('download', false);
                this._enableEle('pause', false);
                this._enableEle('resume', false);
                this._stop = false;
                this._blobURL = null;
            }

            async start() {
                this._stop = false;
                this._blobURL = null;
                this._ext = "mp4"
                this._close();
                this._enableEle('start', false);
                this._enableEle('stop', true);
                this._enableEle('download', false);
                this._enableEle('pause', true);
                this._enableEle('resume', false);

                this._recordStreams = await this._captureRecordStreams(this._captures, () => this.stop());

                let recordOptions = {};
                if (this._recordStreams.isVideo) {
                    this._ext = "mp4"
                    recordOptions = Object.assign(recordOptions, {
                        type: 'video',
                        mimeType: 'video/mp4',
                    });
                } else {
                    this._ext = "mp3"
                    let audioOptions = {
                        type: 'audio',
                    };
                    if (IsSafari() || IsEdge()) {
                        audioOptions.recorderType = StereoAudioRecorder;
                        audioOptions.numberOfAudioChannels = IsEdge() ? 1 : 2;
                    }
                    recordOptions = Object.assign(recordOptions, audioOptions);
                }

                if (this._recordStreams.isVideo) {
                    recordOptions.previewStream = (preview) => this._preview('videoRecordingPreview', preview, 0);
                }
                this._callback('start', this._recordStreams);
                this._recorder = RecordRTC(this._recordStreams, recordOptions);
                this._recorder.startRecording();
            }

            stop() {
                if (this._stop) return;
                this._stop = true;
                if (!this._recorder) return;
                this._recorder.stopRecording((blobURL) => {
                    const isVideo = this._recordStreams.isVideo;
                    this._blobURL = blobURL;
                    if (isVideo) {
                        this._preview('videoRecordingPreview', null);
                        this._preview('videoFinishPreview', this._blobURL, 1);
                    } else {
                        this._preview('audioFinishPreview', this._blobURL, 1);
                    }
                    this._callback('stop', isVideo, this._blobURL);
                    this._close();
                    this._enableEle('start', true);
                    this._enableEle('stop', false);
                    this._enableEle('download', true);
                });
            }

            download() {
                if (this._blobURL) {
                    this._saveURLToDisk(this._blobURL, this._ext);
                    this._callback('download', this._blobURL);
                }
            }

            pause() {
                if (this._recorder) {
                    this._recorder.pauseRecording();
                    this._enableEle('pause', false);
                    this._enableEle('resume', true);
                    this._callback('pause');
                }
            }

            resume() {
                if (this._recorder) {
                    this._recorder.resumeRecording();
                    this._enableEle('pause', true);
                    this._enableEle('resume', false);
                    this._callback('resume');
                }
            }



            _initUIListeners(uis) {
                this._uiListeners = {
                    start: null,
                    stop: null,
                    download: null,
                    pause: null,
                    resume: null,
                    videoPreview: null,
                    videoFinishPreview: null,
                    audioFinishPreview: null,

                    cameraCheckbox: null,
                    microphoneCheckbox: null,
                    screenCheckbox: null,
                    systemAudioCheckbox: null,
                };
                this._captures = {};
                for (const ui in uis) {
                    const obj = uis[ui];
                    if (typeof obj === 'function') {
                        this._addUICallback(ui, obj);
                    } else if (typeof obj === 'string') {
                        this._addUIEle(ui, obj);
                    } else if (typeof obj === 'object') {
                        this._addUICallback(ui, obj.callback);
                        if (obj.hasOwnProperty('button')) {
                            this._addUIEle(ui, obj.button);
                        }
                        if (obj.hasOwnProperty('selector')) {
                            this._addUIEle(ui, obj.selector);
                        }
                        if (this._uiListeners[ui] && this._uiListeners[ui].ele && obj.hasOwnProperty('enable')) {
                            this._uiListeners[ui].ele.disabled = !obj.enable;
                        }
                    }
                    if (!this._uiListeners[ui]) {
                        continue;
                    }
                    const ele = this._uiListeners[ui].ele;
                    if (!ele) {
                        continue;
                    }
                    switch (ui) {
                        case 'start':
                            ele.addEventListener('click', this.start.bind(this));
                            break;
                        case 'stop':
                            ele.addEventListener('click', this.stop.bind(this));
                            break;
                        case 'download':
                            ele.addEventListener('click', this.download.bind(this));
                            break;
                        case 'pause':
                            ele.addEventListener('click', this.pause.bind(this));
                            break;
                        case 'resume':
                            ele.addEventListener('click', this.resume.bind(this));
                            break;
                        case 'reset':
                            ele.addEventListener('click', this.reset.bind(this));
                            break;
                        case 'cameraCheckbox':
                            ele.addEventListener('change', () => {
                                this._captures.camera = ele.checked;
                            });
                            this._captures.camera = ele.checked;
                            break;
                        case 'microphoneCheckbox':
                            ele.addEventListener('change', () => {
                                this._captures.microphone = ele.checked;
                            });
                            this._captures.microphone = ele.checked;
                            break;
                        case 'screenCheckbox':
                            ele.addEventListener('change', () => {
                                this._captures.screen = ele.checked;
                            });
                            this._captures.screen = ele.checked;
                            break;

                        case 'systemAudioCheckbox':
                            ele.addEventListener('change', () => {
                                this._captures.systemAudio = ele.checked;
                            });
                            this._captures.systemAudio = ele.checked;
                            break;
                    }
                }
            }

            _addUICallback(event, callback) {
                if (!event || !callback) return;
                if (!this._uiListeners[event]) {
                    this._uiListeners[event] = {
                        callbacks: []
                    }
                }
                if (!this._uiListeners[event].callbacks) {
                    this._uiListeners[event].callbacks = [];
                }
                this._uiListeners[event].callbacks.push(callback);
            }

            _addUIEle(event, ele) {
                if (!event || !ele) return;
                if (!this._uiListeners[event]) {
                    this._uiListeners[event] = {}
                }
                if (typeof ele === 'string') {
                    ele = document.querySelector(ele);
                }
                this._uiListeners[event].ele = ele;
            }

            _callback(event, ...args) {
                const listener = this._uiListeners[event];
                if (listener && listener.callbacks) {
                    listener.callbacks.forEach(callback => callback(...args));
                }
            }

            _enableEle(btn, enable) {
                if (typeof btn === 'string') {
                    btn = this._uiListeners[btn].ele;
                }
                if (btn) {
                    btn.disabled = !enable;
                }
            }

            _preview(ele, src, volume) {
                if (!ele) return;
                if (typeof ele === 'string') {
                    ele = this._uiListeners[ele].ele;
                }
                ele.src = ele.srcObject = null;
                if (!src) return;

                if (ele.style.display === 'none') {
                    ele.style.display = 'block';
                }
                if (volume) {
                    ele.muted = false;
                    ele.volume = volume;
                } else {
                    ele.muted = true;
                }
                if (typeof src === 'string') {
                    ele.src = src;
                } else {
                    ele.srcObject = src;
                }
            }

            async _captureRecordStreams(captures, streamStopCallback) {
                try {
                    let hasCaptureSystemAudio = false;
                    let hasCaptureMicrophone = false;
                    let streams = [];
                    if (captures.screen) {
                        const screen = await this._getDisplayMedia({ video: true, audio: captures.systemAudio });
                        streams.screen = screen;
                        streams.isVideo = true;
                        streams.push(screen);
                        hasCaptureSystemAudio = captures.systemAudio;

                        const keepStreamActive = document.createElement('video');
                        keepStreamActive.muted = true;
                        keepStreamActive.srcObject = screen;
                        keepStreamActive.style.display = 'none';
                        (document.body || document.documentElement).appendChild(keepStreamActive);
                        this.onStop(() => {
                            keepStreamActive.srcObject = null;
                            (document.body || document.documentElement).removeChild(keepStreamActive);
                        })
                    }
                    if (!hasCaptureSystemAudio && captures.systemAudio) {
                        const systemAudio = await this._getDisplayMedia({ audio: true });
                        streams.systemAudio = systemAudio;
                        streams.push(systemAudio);
                    }
                    if (captures.camera) {
                        const camera = await this._getUserMedia({ video: true, audio: captures.microphone })
                        streams.camera = camera
                        streams.isVideo = true
                        streams.push(camera);
                        hasCaptureMicrophone = captures.microphone;
                    }
                    if (!hasCaptureMicrophone && captures.microphone) {
                        const microphone = await this._getUserMedia({ audio: true })
                        streams.microphone = microphone
                        streams.push(microphone);
                    }
                    if (streams.screen && streams.camera) {
                        streams.screen.width = window.screen.width;
                        streams.screen.height = window.screen.height;
                        streams.screen.fullcanvas = true;
                        streams.camera.width = 320;
                        streams.camera.height = 240;
                        streams.camera.top = streams.screen.height - streams.camera.height;
                        streams.camera.left = streams.screen.width - streams.camera.width;
                    }

                    if (streamStopCallback) {
                        if (Array.isArray(streams)) {
                            streams.forEach(stream => this._addStreamStopListener(stream, streamStopCallback));
                        } else {
                            this._addStreamStopListener(streams, streamStopCallback);
                        }
                    }
                    return streams;
                } catch (e) {
                    alert('Error capturing streams: ' + e.message);
                    console.error(e);
                }
            }

            async _getUserMedia(constraints) {
                if (typeof navigator.mediaDevices === 'undefined' || !navigator.mediaDevices.getUserMedia) {
                    alert('This browser does not supports WebRTC getUserMedia API.');
                    throw new Error('getUserMedia is not supported by this browser');
                }
                return await navigator.mediaDevices.getUserMedia(constraints);
            }

            async _getDisplayMedia(constraints) {
                if (!navigator.getDisplayMedia && !navigator.mediaDevices.getDisplayMedia) {
                    alert('This browser does not supports WebRTC getDisplayMedia API.');
                    throw new Error('getDisplayMedia is not supported by this browser');
                }
                return await navigator.mediaDevices.getDisplayMedia(constraints);
            }

            _addStreamStopListener(stream, callback) {
                if (!stream || !callback) {
                    return;
                }
                stream.addEventListener('ended', function () {
                    callback();
                    callback = function () { };
                }, false);
                stream.addEventListener('inactive', function () {
                    callback();
                    callback = function () { };
                }, false);
                stream.getTracks().forEach(function (track) {
                    track.addEventListener('ended', function () {
                        callback();
                        callback = function () { };
                    }, false);
                    track.addEventListener('inactive', function () {
                        callback();
                        callback = function () { };
                    }, false);
                });
            }

            _saveURLToDisk(fileURL, ext, prefix = "redord-") {
                const now = new Date();
                const year = now.getFullYear();
                const month = (now.getMonth() + 1).toString().padStart(2, '0'); // 月份从0开始，需要加1
                const day = now.getDate().toString().padStart(2, '0');
                const hours = now.getHours().toString().padStart(2, '0');
                const minutes = now.getMinutes().toString().padStart(2, '0');
                const seconds = now.getSeconds().toString().padStart(2, '0');
                const formattedDateTime = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
                const fileName = prefix + formattedDateTime + '.' + ext;

                // for non-IE
                if (!window.ActiveXObject) {
                    let save = document.createElement('a');
                    save.href = fileURL;
                    save.download = fileName || 'unknown';
                    save.style = 'display:none;opacity:0;color:transparent;';
                    (document.body || document.documentElement).appendChild(save);
                    if (typeof save.click === 'function') {
                        save.click();
                    } else {
                        save.target = '_blank';
                        let event = document.createEvent('Event');
                        event.initEvent('click', true, true);
                        save.dispatchEvent(event);
                    }
                    (window.URL || window.webkitURL).revokeObjectURL(save.href);
                }
                // for IE
                else if (!!window.ActiveXObject && document.execCommand) {
                    let _window = window.open(fileURL, '_blank');
                    _window.document.close();
                    _window.document.execCommand('SaveAs', true, fileName || fileURL)
                    _window.close();
                }
            }

            _close(reset) {
                if (!this._recordStreams) return;
                const callStop = (obj) => {
                    if (obj && typeof obj.stop === 'function') {
                        obj.stop();
                    }
                }
                callStop(this._recordStreams.camera);
                callStop(this._recordStreams.microphone);
                callStop(this._recordStreams.screen);
                callStop(this._recordStreams.systemAudio);
                if (Array.isArray(this.recordStreams)) {
                    for (const stream of this._recordStreams) {
                        callStop(stream)
                    }
                    callStop(this._recordStreams);
                    this._recordStreams = null;
                }
                if (reset && this._recorder) {
                    this._recorder.reset();
                }
                if (this._recorder) {
                    this._recorder.destroy();
                    this._recorder = null;
                }
            };
        }
    </script>

    <script>
        const app = new MediaRecorderApp({
            events: {
                start: '#btn-start-recording',
                stop: '#btn-stop-recording',
                pause: '#btn-pause-recording',
                resume: '#btn-resume-recording',
                download: '#btn-download-recording',
                reset: '#btn-reset',
                videoRecordingPreview: 'video',
                videoFinishPreview: 'video',
                audioFinishPreview: 'audio',

                cameraCheckbox: '#checkbox-camera',
                microphoneCheckbox: '#checkbox-microphone',
                screenCheckbox: '#checkbox-screen',
                systemAudioCheckbox: '#checkbox-system-audio',

            }
        });
    </script>
</body>

</html>