<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="tip"></div>

    <button id="btn-start-recording">Start Recording</button>
    <button id="btn-stop-recording" disabled>Stop Recording</button>
    <button id="btn-pause-recording" disabled>Pause Recording</button>
    <button id="btn-resume-recording" disabled>Resume Recording</button>
    <button id="btn-download-recording" disabled>Download</button>
    <button id="btn-discard">Discard</button>

    <br /><br />

    <input type="checkbox" id="checkbox-camera" checked> Camera</checkbox>
    <input type="checkbox" id="checkbox-microphone"> Microphone</input>
    <input type="checkbox" id="checkbox-screen">Screen</input>
    <input type="checkbox" id="checkbox-system-audio"> System Audio</input>
    <input type="checkbox" id="checkbox-speaking"> 监听声音</input>

    <hr>
    <div>
        <audio autoplay playsinline></audio>
        <video autoplay playsinline style="width: 200px; height: 200px;"></video>
    </div>

    <script src="https://www.WebRTC-Experiment.com/RecordRTC.js"></script>
    <script src="https://www.webrtc-experiment.com/hark.js"></script>

    <script>
        function IsEdge() {
            if (typeof window.__isEdge !== 'undefined') {
                return window.__isEdge;
            }
            window.__isEdge = navigator.userAgent.indexOf('Edge') !== -1 && (!!navigator.msSaveOrOpenBlob || !!navigator.msSaveBlob);
            return window.__isEdge;
        }

        function IsSafari() {
            if (typeof window.__isSafari !== 'undefined') {
                return window.__isSafari;
            }
            window.__isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
            return window.__isSafari;
        }

        class MediaRecorderApp {
            onStop(callback) {
                this._addHook('stop', callback);
            }
            onDownload(callback) {
                this._addHook('download', callback);
            }
            onStart(callback) {
                this._addHook('start', callback);
            }
            onPause(callback) {
                this._addHook('pause', callback);
            }
            onResume(callback) {
                this._addHook('resume', callback);
            }
            onDiscard(callback) {
                this._addHook('discard', callback);
            }
            onCaptureBefore(callback) {
                this._addHook('capturebefore', callback);
            }
            onCaptureAfter(callback) {
                this._addHook('captureafter', callback);
            }
            onCaptureError(callback) {
                this._addHook('captureerror', callback);
            }

            discard() {
                this.clean(true);
                this._callback('discard');
            }

            clean(reset) {
                this._stop = false;
                this._blobURL = null;
                this._close(reset);
            }

            async start({ captures }) {
                if (!captures.camera && !captures.microphone && !captures.screen && !captures.systemAudio) {
                    console.log('Please select at least one media source to record.');
                    return;
                }
                this.clean(true);

                this._ext = "webm"
                this._callback('capturebefore', captures);
                this._recordStreams = await this._captureRecordStreams(captures, () => this.stop());
                this._callback('captureafter', this._recordStreams);

                let recordOptions = {};
                if (this._recordStreams.isVideo) {
                    this._ext = "webm"
                    recordOptions = Object.assign(recordOptions, {
                        type: 'video',
                        mimeType: 'video/webm',
                    });
                } else {
                    this._ext = "mp3"
                    let audioOptions = {
                        type: 'audio',
                    };
                    if (IsSafari() || IsEdge()) {
                        audioOptions.recorderType = StereoAudioRecorder;
                        audioOptions.numberOfAudioChannels = IsEdge() ? 1 : 2;
                    }
                    recordOptions = Object.assign(recordOptions, audioOptions);
                }

                recordOptions.previewStream = (preview) => {
                    this._callback('start', this._recordStreams, preview);
                };
                this._recorder = RecordRTC(this._recordStreams, recordOptions);


                this._recorder.startRecording();
            }

            stop() {
                if (this._stop) return;
                this._stop = true;
                if (!this._recorder) return;
                this._recorder.stopRecording((blobURL) => {
                    this._blobURL = blobURL;
                    const isVideo = this._recordStreams && this._recordStreams.isVideo;
                    this._close();
                    this._callback('stop', isVideo, this._blobURL);
                });
            }

            download() {
                if (this._blobURL) {
                    this._saveURLToDisk(this._blobURL, this._ext);
                    this._callback('download');
                }
            }

            pause() {
                if (this._recorder) {
                    this._recorder.pauseRecording();
                    this._callback('pause');
                }
            }

            state() {
                return this._recorder.getState();
            }

            blog() {
                return this._recorder.getBlob();
            }

            resume() {
                if (this._recorder) {
                    this._recorder.resumeRecording();
                    this._callback('resume');
                }
            }

            _addHook(event, callback) {
                if (!event || !callback) return;
                if (!this._hooks) {
                    this._hooks = {};
                }
                if (!this._hooks[event]) {
                    this._hooks[event] = [];
                }
                this._hooks[event].push(callback);
            }

            _hasHook(event) {
                if (!event || !this._hooks) return false;
                return !!this._hooks[event];
            }

            _callback(event, ...args) {
                if (!event || !this._hooks) return;
                const callbacks = this._hooks[event];
                if (callbacks) {
                    callbacks.forEach(callback => callback(...args));
                }
            }

            async _captureRecordStreams(captures, streamStopCallback) {
                try {
                    let streams = [];
                    if (captures.screen) {
                        const screen = await this._getDisplayMedia({ video: true, audio: captures.systemAudio });
                        streams.screen = screen;
                        streams.isVideo = true;
                        streams.systemAudio = captures.systemAudio;
                        streams.push(screen);

                        const keepStreamActive = document.createElement('video');
                        keepStreamActive.muted = true;
                        keepStreamActive.srcObject = screen;
                        keepStreamActive.style.display = 'none';
                        (document.body || document.documentElement).appendChild(keepStreamActive);
                        this.onStop(() => {
                            keepStreamActive.srcObject = null;
                            (document.body || document.documentElement).removeChild(keepStreamActive);
                        })
                    }
                    if (!streams.systemAudio && captures.systemAudio) {
                        const systemAudio = await this._getDisplayMedia({ audio: true });
                        streams.systemAudio = systemAudio;
                        streams.push(systemAudio);
                    }
                    if (captures.camera) {
                        const camera = await this._getUserMedia({ video: true, audio: captures.microphone });
                        streams.camera = camera;
                        streams.isVideo = true;
                        streams.microphone = captures.microphone;
                        streams.push(camera);
                    }
                    if (!streams.microphone && captures.microphone) {
                        const microphone = await this._getUserMedia({ audio: true })
                        streams.microphone = microphone
                        streams.push(microphone);
                    }
                    if (streams.screen && streams.camera) {
                        streams.screen.width = window.screen.width;
                        streams.screen.height = window.screen.height;
                        streams.screen.fullcanvas = true;
                        streams.camera.width = 320;
                        streams.camera.height = 240;
                        if (streams.camera.width > streams.screen.width / 3) {
                            streams.camera.width = streams.screen.width / 3;
                        }
                        if (streams.camera.height > streams.screen.height / 3) {
                            streams.camera.height = streams.screen.height / 3;
                        }
                        streams.camera.top = streams.screen.height - streams.camera.height;
                        streams.camera.left = streams.screen.width - streams.camera.width;
                    }

                    if (streamStopCallback) {
                        if (Array.isArray(streams)) {
                            streams.forEach(stream => this._addStreamStopListener(stream, streamStopCallback));
                        } else {
                            this._addStreamStopListener(streams, streamStopCallback);
                        }
                    }
                    return streams;
                } catch (e) {
                    console.error(e);
                }
            }

            async _getUserMedia(constraints) {
                if (typeof navigator.mediaDevices === 'undefined' || !navigator.mediaDevices.getUserMedia) {
                    alert('This browser does not supports WebRTC getUserMedia API.');
                    throw new Error('getUserMedia is not supported by this browser');
                }
                try {
                    return await navigator.mediaDevices.getUserMedia(constraints);
                } catch (e) {
                    this._callback('captureerror', {
                        error: e,
                        camera: constraints.video,
                        microphone: constraints.audio,
                    });
                    throw e;
                }
            }

            async _getDisplayMedia(constraints) {
                if (!navigator.getDisplayMedia && !navigator.mediaDevices.getDisplayMedia) {
                    alert('This browser does not supports WebRTC getDisplayMedia API.');
                    throw new Error('getDisplayMedia is not supported by this browser');
                }
                try {
                    return await navigator.mediaDevices.getDisplayMedia(constraints);
                } catch (e) {
                    this._callback('captureerror', {
                        error: e,
                        screen: constraints.video,
                        systemAudio: constraints.audio,
                    });
                    throw e;
                }
            }

            _addStreamStopListener(stream, callback) {
                if (!stream || !callback) {
                    return;
                }
                stream.addEventListener('ended', function () {
                    callback();
                    callback = function () { };
                }, false);
                stream.addEventListener('inactive', function () {
                    callback();
                    callback = function () { };
                }, false);
                stream.getTracks().forEach(function (track) {
                    track.addEventListener('ended', function () {
                        callback();
                        callback = function () { };
                    }, false);
                    track.addEventListener('inactive', function () {
                        callback();
                        callback = function () { };
                    }, false);
                });
            }

            _saveURLToDisk(fileURL, ext, prefix = "redord-") {
                const now = new Date();
                const year = now.getFullYear();
                const month = (now.getMonth() + 1).toString().padStart(2, '0'); // 月份从0开始，需要加1
                const day = now.getDate().toString().padStart(2, '0');
                const hours = now.getHours().toString().padStart(2, '0');
                const minutes = now.getMinutes().toString().padStart(2, '0');
                const seconds = now.getSeconds().toString().padStart(2, '0');
                const formattedDateTime = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
                const fileName = prefix + formattedDateTime + '.' + ext;

                // for non-IE
                if (!window.ActiveXObject) {
                    let save = document.createElement('a');
                    save.href = fileURL;
                    save.download = fileName || 'unknown';
                    save.style = 'display:none;opacity:0;color:transparent;';
                    (document.body || document.documentElement).appendChild(save);
                    if (typeof save.click === 'function') {
                        save.click();
                    } else {
                        save.target = '_blank';
                        let event = document.createEvent('Event');
                        event.initEvent('click', true, true);
                        save.dispatchEvent(event);
                    }
                    (window.URL || window.webkitURL).revokeObjectURL(save.href);
                }
                // for IE
                else if (!!window.ActiveXObject && document.execCommand) {
                    let _window = window.open(fileURL, '_blank');
                    _window.document.close();
                    _window.document.execCommand('SaveAs', true, fileName || fileURL)
                    _window.close();
                }
            }

            _close(reset) {
                if (!this._recordStreams) return;
                const callStop = (obj) => {
                    if (obj && typeof obj.stop === 'function') {
                        obj.stop();
                    }
                }
                callStop(this._recordStreams.camera);
                callStop(this._recordStreams.microphone);
                callStop(this._recordStreams.screen);
                callStop(this._recordStreams.systemAudio);
                if (Array.isArray(this.recordStreams)) {
                    for (const stream of this._recordStreams) {
                        callStop(stream)
                    }
                    callStop(this._recordStreams);
                }
                if (reset && this._recorder) {
                    this._recorder.reset();
                }
                if (this._recorder) {
                    this._recorder.destroy();
                }
                this._recordStreams = null;
                this._recorder = null;
            };
        }


        class SpeakingListener {
            listen({ stream, timeoutSeconds }) {
                this._timeoutHandle;
                this._hark = hark(stream, {});
                this._hark.on('speaking', () => {
                    if (this._timeoutHandle) {
                        clearTimeout(this._timeoutHandle);
                        this._timeoutHandle = null;
                    }
                    if (this._speakingHooks) {
                        this._speakingHooks.forEach(callback => callback());
                    }
                });
                this._hark.on('stopped_speaking', () => {
                    this._timeoutHandle = setTimeout(() => {
                        if (this._stopSpeakingHooks) {
                            this._stopSpeakingHooks.forEach(callback => callback());
                        }
                    }, timeoutSeconds * 1000);
                });
            }

            stop() {
                if (this._hark) {
                    this._hark.stop();
                    this._hark = null;
                }
                if (this._timeoutHandle) {
                    clearTimeout(this._timeoutHandle);
                    this._timeoutHandle = null;
                }
            }
            onSpeaking(callback) {
                if (this._speakingHooks) {
                    this._speakingHooks.push(callback);
                } else {
                    this._speakingHooks = [callback];
                }
            }
            onStopSpeaking(callback) {
                if (this._stopSpeakingHooks) {
                    this._stopSpeakingHooks.push(callback);
                } else {
                    this._stopSpeakingHooks = [callback];
                }
            }
        }

        const startBtn = document.querySelector('#btn-start-recording');
        const stopBtn = document.querySelector('#btn-stop-recording');
        const pauseBtn = document.querySelector('#btn-pause-recording');
        const resumeBtn = document.querySelector('#btn-resume-recording');
        const downloadBtn = document.querySelector('#btn-download-recording');
        const discardBtn = document.querySelector('#btn-discard');
        const cameraCheckbox = document.querySelector('#checkbox-camera');
        const microphoneCheckbox = document.querySelector('#checkbox-microphone');
        const screenCheckbox = document.querySelector('#checkbox-screen');
        const systemAudioCheckbox = document.querySelector('#checkbox-system-audio');
        const videoPreview = document.querySelector('video');
        const audioPreview = document.querySelector('audio');
        const speakingCheckBok = document.querySelector('#checkbox-speaking');
        const tip = document.querySelector('#tip');

        function enableEle(...eles) {
            eles.forEach(ele => ele.disabled = false);
        }
        function disableEle(...eles) {
            eles.forEach(ele => ele.disabled = true);
        }

        let globalSpeakLister;
        let globalApp;
        function initApp(listenSpeak) {
            let isVideoPlaying = false;
            videoPreview.onplaying = function () {
                isVideoPlaying = true;
            };
            videoPreview.onpause = function () {
                isVideoPlaying = false;
            };
            videoPreview.onended = function () {
                isVideoPlaying = false;
            };
            let isAudioPlaying = false;
            audioPreview.onplaying = function () {
                isAudioPlaying = true;
            };
            audioPreview.onpause = function () {
                isAudioPlaying = false;
            };
            audioPreview.onended = function () {
                isAudioPlaying = false;
            };

            if (globalSpeakLister) {
                globalSpeakLister.stop();
            }
            globalSpeakLister = new SpeakingListener()
            if (globalApp) {
                globalApp.clean();
            }
            globalApp = new MediaRecorderApp();

            globalApp.onCaptureBefore(() => {
                tip.innerHTML = 'Preparing...';
            })
            globalApp.onCaptureAfter((recordStreams) => {
                tip.innerHTML = '';
            })
            globalApp.onStart((recordStreams, preview) => {
                disableEle(startBtn, downloadBtn, resumeBtn);
                enableEle(stopBtn, pauseBtn, discardBtn);

                if (listenSpeak && recordStreams.microphone) {
                    globalSpeakLister.listen({
                        stream: preview,
                        timeoutSeconds: 3,
                    })
                }

                if (recordStreams.isVideo && preview) {
                    videoPreview.style.display = 'block';
                    videoPreview.src = null;
                    videoPreview.srcObject = preview;
                    videoPreview.muted = true;
                }
            })
            globalApp.onStop((isVideo, blobURL) => {
                globalSpeakLister.stop()

                disableEle(startBtn, stopBtn, pauseBtn, resumeBtn);
                enableEle(discardBtn, downloadBtn);
                if (isVideo) {
                    videoPreview.src = videoPreview.srcObject = null;
                    videoPreview.src = blobURL;
                    videoPreview.muted = false;
                    videoPreview.load();
                } else {
                    audioPreview.src = audioPreview.srcObject = null;
                    audioPreview.src = blobURL;
                    audioPreview.muted = false;
                    audioPreview.load();
                }
            })
            globalApp.onPause(() => {
                disableEle(startBtn, pauseBtn, downloadBtn);
                enableEle(stopBtn, resumeBtn, discardBtn);
                if (videoPreview.played && isVideoPlaying) {
                    videoPreview.pause();
                }
            })
            globalApp.onResume(() => {
                disableEle(startBtn, resumeBtn, downloadBtn);
                enableEle(stopBtn, pauseBtn, discardBtn);
                if (videoPreview.paused && !isVideoPlaying) {
                    videoPreview.play();
                }
            })
            globalApp.onDownload(() => { })
            globalApp.onDiscard(() => {
                globalSpeakLister.stop();

                enableEle(startBtn);
                disableEle(stopBtn, pauseBtn, resumeBtn, downloadBtn, discardBtn);
                videoPreview.src = videoPreview.srcObject = null;
                audioPreview.src = audioPreview.srcObject = null;
                videoPreview.load();
                audioPreview.load();
            })
            globalApp.onCaptureError((errorObj) => {
                let errorDevices = [];
                if (errorObj.camera) {
                    errorDevices.push('Camera');
                }
                if (errorObj.microphone) {
                    errorDevices.push('Microphone');
                }
                if (errorObj.screen) {
                    errorDevices.push('Screen');
                }
                if (errorObj.systemAudio) {
                    errorDevices.push('System Audio');
                }
                const errorMsg = "Cannot capture " + errorDevices.join(' and ') + ". Error: " + errorObj.error.message;
                alert(errorMsg);
            })


            globalSpeakLister.onSpeaking(() => {
                console.log('speaking');
                if (!resumeBtn.disabled) {
                    resumeBtn.click();
                }
            })
            globalSpeakLister.onStopSpeaking(() => {
                console.log('stop speaking');
                if (!pauseBtn.disabled) {
                    pauseBtn.click();
                }
            })
            return globalApp;
        }

        enableEle(startBtn);
        disableEle(stopBtn, pauseBtn, resumeBtn, downloadBtn, discardBtn);

        startBtn.addEventListener('click', async () => {
            initApp(speakingCheckBok.checked);
            await globalApp.start({
                captures: {
                    camera: cameraCheckbox.checked,
                    microphone: microphoneCheckbox.checked,
                    screen: screenCheckbox.checked,
                    systemAudio: systemAudioCheckbox.checked,
                },
            });
        });
        stopBtn.addEventListener('click', () => globalApp.stop());
        pauseBtn.addEventListener('click', () => globalApp.pause());
        resumeBtn.addEventListener('click', () => globalApp.resume());
        downloadBtn.addEventListener('click', () => globalApp.download());
        discardBtn.addEventListener('click', () => globalApp.discard());
        speakingCheckBok.addEventListener('change', () => {
            if (speakingCheckBok.checked) {
                microphoneCheckbox.checked = true;
            }
        })
    </script>
</body>

</html>